{"version":3,"file":"index-3e14eaf0.js","sources":["../src/common/index.js","../node_modules/_fflate@0.4.8@fflate/esm/browser.js","../src/pack.js","../src/config/index.js","../src/utils.js","../src/api/request.js","../src/api/index.js","../src/prototype/index.js","../src/common/registBaseEvent.js","../src/index.js"],"sourcesContent":["const ua = navigator.userAgent\nconst referrer = document.referrer\n\n// 获取当前时间戳\nexport const getCurrentTime = () => new Date().getTime()\n\n// 生成随机ID\nexport const getRandomID = () => {\n  return ('' + getCurrentTime() * Math.random()).slice(0, 8)\n}\n\n// 获取当前相对于页面打开时的时间戳\nexport const getTimeStamp = () => ~~(performance.now())\n// 自定义事件触发的公共方法\nexport const eventTrigger = function (event) {\n  window.dispatchEvent(new CustomEvent(event, { detail: { target: this, time: getCurrentTime() } }));\n}\n\nexport const isFunction = fn => typeof fn === 'function'\n\n// 判断是否是成功的请求状态码,不包含跨域，超时等请求\nexport const isSuccess = (status) => status < 400\n\n// 获取Dom的xpath\nexport const getXPath = (element) => {\n  if (element.id !== \"\") {//判断id属性，如果这个元素有id，则显 示//*[@id=\"xPath\"]  形式内容\n    return `//*[@id=\"${element.id}\"]`;\n  }\n  //这里需要需要主要字符串转译问题，可参考js 动态生成html时字符串和变量转译（注意引号的作用）\n  if (element == document.body) {//递归到body处，结束递归\n    return '/html/' + element.tagName.toLowerCase();\n  }\n  var ix = 1,//在nodelist中的位置，且每次点击初始化\n    siblings = element.parentNode.childNodes;//同级的子元素\n\n  for (var i = 0, l = siblings.length; i < l; i++) {\n    var sibling = siblings[i];\n    //如果这个元素是siblings数组中的元素，则执行递归操作\n    if (sibling == element) {\n      return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix) + ']';\n      //如果不符合，判断是否是element元素，并且是否是相同元素，如果是相同的就开始累加\n    } else if (sibling.nodeType == 1 && sibling.tagName == element.tagName) {\n      ix++;\n    }\n  }\n};\n// 获取省略字符，中间用省略号代替\nexport const getSimpleString = (str, length = 200) => {\n  // 如果点击的内容过长，就截取上传\n  str = typeof str === 'string' ? str : JSON.stringify(str)\n  if (str && str.length > length) {\n    const len = Math.max(length - 100, 50)\n    str = str.substr(0, len) + '... ...' + str.substr(len - length + 50)\n  }\n  return str || ''\n}\nconst removeHttpAndQuery = (url) =>\n  url.replace(/^[^/]*:?\\/\\//, '').split('?')[0]\n// 判断是不是在白名单\nexport const isWhite = (list, url) => {\n  return list.some((i) => {\n    if (i instanceof RegExp) return i.test(url)\n    if (typeof i !== 'string') return\n    return removeHttpAndQuery(i) === removeHttpAndQuery(url)\n  })\n}\n// 给外链script添加crossorigin属性，防止报anonymous错误\nexport function setScriptCross() {\n  var scripts = document.getElementsByTagName('script')\n  for (var s of scripts) {\n    const url = removeHttpAndQuery(s.src || '')\n    url && url[0] !== '/' && s.setAttribute('crossorigin', 'anonymous');\n  }\n}\nexport const isIE8 = () => {\n  var ua = navigator.userAgent.toLowerCase()\n\n  var isIE = ua.indexOf('msie') > -1\n\n  var safariVersion = isIE ? ua.match(/msie ([\\d.]+)/)[1] : 100\n  return safariVersion <= 8\n}\n\n//获取元素的tagName, 兼容极低版本的问题\nexport const getTagName = (el) => {\n  if (!el) return ''\n  if (el === document) return 'html'\n  if (el.tagName) return el.tagName\n  return el.outerHTML.match(/<([^>\\s]+)/)[1]\n}\n\n\n// 组合 参数\nexport const getErrorInfo = err => {\n  const error = err.error || {}\n  return {\n    type: err._type || err.type, // 错误的类型，如httpError\n    name: (err.name || err.message && err.message.split(':')[0] || err.type)?.replace(/^Uncaught\\s/, ''), // 错误信息的名称\n    message: getSimpleString(err.message || err.description || '', 300), // 错误信息的内容\n    extraInfo: err.extraInfo || null,\n    stacktrace: err.error && error.stack, // 错误的执行栈\n    target: err._target,\n    timeStamp: getTimeStamp(),\n    title: document.title, // 报错页面的标题\n    referrer, // 从哪个页面跳转过来\n    url: location.href,\n    userAgent: ua,\n    columnNumber: err.colno || error.columnNumber,\n    lineNumber: err.lineno || error.lineNumber,\n    cookie: document.cookie,\n    version: EDITH_VERSION, // Edith版本号\n    // performance: getPerform(),\n    // locale: navigator.browserLanguage || navigator.language,\n    // severity: err.severity,\n\n    // notifierVersion: '1.0.0', // 通知的版本号\n    // revideoVersion: '', // 回放插件的版本号 \n    // releaseStage: '', // 错误发生的环境，production| development\n    // time: +new Date(), // 错误发生的时间戳\n  }\n}\n\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Much of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// Many optimizations have been made, so the bundle size is ultimately smaller but performance is similar.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var u = ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' })));\n    var w = new Worker(u);\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i)\n            co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) >> 0;\n    return ((d[o] | (d[o + 1] << 8)) >>> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) >> 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >>> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) >> 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                if (!noSt && pos + tl * (clb + 7) > tbts)\n                    break;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts)\n                throw 'unexpected EOF';\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var mxa = lbt + dbt + 18;\n        while (noSt || pos + mxa < tbts) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts)\n                throw 'unexpected EOF';\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts)\n                    throw 'unexpected EOF';\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = pos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) >> 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) >> 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [new u8(0), 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768\n            var imod = i & 32767;\n            // previous index with this value\n            var pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst)\n            pos = wfblk(w, pos, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new u32(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && 0xEDB88320) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = 0xFFFFFFFF;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return c ^ 0xFFFFFFFF; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 5552, l);\n                for (; i < e; ++i)\n                    n += d[i], m += n;\n                n %= 65521, m %= 65521;\n            }\n            a = n, b = m;\n        },\n        d: function () { return ((a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8)) + ((a & 255) << 23) * 2; }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    if (!opts.consume)\n        dat = new u8(dat);\n    w.postMessage([dat, opts], [dat.buffer]);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16)) + (d[b + 3] << 23) * 2; };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) + (2 * (d[l - 1] << 23));\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    return dopt(data, opts, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) >> 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = gzs(this.p);\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    var l = str.length;\n    if (!latin1 && typeof TextEncoder != 'undefined')\n        return new TextEncoder().encode(str);\n    var ar = new u8(str.length + (str.length >>> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >>> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >>> 18)), w(128 | ((c >>> 12) & 63)), w(128 | ((c >>> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >>> 12)), w(128 | ((c >>> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    var r = '';\n    if (!latin1 && typeof TextDecoder != 'undefined')\n        return new TextDecoder().decode(dat);\n    for (var i = 0; i < dat.length;) {\n        var c = dat[i++];\n        if (c < 128 || latin1)\n            r += String.fromCharCode(c);\n        else if (c < 224)\n            r += String.fromCharCode((c & 31) << 6 | (dat[i++] & 63));\n        else if (c < 240)\n            r += String.fromCharCode((c & 15) << 12 | (dat[i++] & 63) << 6 | (dat[i++] & 63));\n        else\n            c = ((c & 15) << 18 | (dat[i++] & 63) << 12 | (dat[i++] & 63) << 6 | (dat[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n    }\n    return r;\n}\n;\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl;\n    var _a = z ? z64e(d, es) : [b4(d, b + 20), b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b4(d, b + 12), b4(d, b + 4), b4(d, b + 20)];\n};\n// write zip header\nvar wzh = function (d, b, c, cmp, su, fn, u, o, ce, t) {\n    var fl = fn.length, l = cmp.length;\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b] = 20, b += 2;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (t == 8 && (o.level == 1 ? 6 : o.level < 6 ? 4 : o.level == 9 ? 2 : 0)), d[b++] = u && 8;\n    d[b] = t, b += 2;\n    var dt = new Date(o.mtime || Date.now()), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, ((y << 24) * 2) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1));\n    b += 4;\n    wbytes(d, b, c);\n    wbytes(d, b + 4, l);\n    wbytes(d, b + 8, su);\n    wbytes(d, b + 12, fl), b += 16; // skip extra field, comment\n    if (ce != null)\n        wbytes(d, b += 10, ce), b += 4;\n    d.set(fn, b);\n    b += fl;\n    if (ce == null)\n        d.set(cmp, b);\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                wzh(out, tot, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);\n                wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, tot, f.t), o += 46 + f.n.length, tot += 30 + f.n.length + f.d.length;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), m = file.length;\n        c.p(file);\n        var n = strToU8(fn), s = n.length;\n        var t = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = {\n                    t: t,\n                    d: d,\n                    m: m,\n                    c: c.d(),\n                    u: fn.length != l,\n                    n: n,\n                    p: p\n                };\n                o += 30 + s + l;\n                tot += 76 + 2 * s + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (n.length > 65535)\n            cbl('filename too long', null);\n        if (!t)\n            cbl(null, file);\n        else if (m < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var t = p.level == 0 ? 0 : 8;\n        var n = strToU8(fn), s = n.length;\n        if (n.length > 65535)\n            throw 'filename too long';\n        var d = t ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push({\n            t: t,\n            d: d,\n            m: file.length,\n            c: c.d(),\n            u: fn.length != s,\n            n: n,\n            o: o,\n            p: p\n        });\n        o += 30 + s + l;\n        tot += 76 + 2 * s + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);\n        wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, f.o, f.t), o += 46 + f.n.length;\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_2 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_2(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","/**\n * 基于rrweb里的解压方法pack，改造的解压数据方法\n */\nimport { strFromU8, unzlibSync, strToU8, zlibSync } from 'fflate/esm/browser.js'\n// event 可以是任一类型\nexport function pack(event) {\n  event = typeof event === 'string' ? event : JSON.stringify(event)\n  return strFromU8(zlibSync(strToU8(event)), true)\n}\n// raw为字符串\nexport function unpack(raw) {\n  if (typeof raw !== 'string') {\n    return raw\n  }\n  let e\n  try {\n    e = JSON.parse(raw)\n    return e\n  } catch (error) {\n    //\n  }\n  try {\n    e = JSON.parse(strFromU8(unzlibSync(strToU8(raw, true))))\n    return e\n  } catch (error) {\n    console.error(error)\n    return null\n  }\n}\n","// http://testevent-edith.op-center.cn\nexport const serviceRoot = IS_DEV ? 'http://testevent-edith.op-center.cn' : 'https://event-edith.op-center.cn'\n\n// 存储用户行为的本地数据key\nexport const RECORD_KEY = '_edith_record'\n\n// Promise多久未被处理后报错(ms)\nexport const PROMISE_TIMEOUT = 500\n // 默认请求白名单，不记录不报错\nconst ajaxWhiteList = [\n  /op-center\\.cn\\/v1\\/monitor/,\n  /\\/sockjs-node\\/info/, // 忽略代理报错\n]\nif(IS_DEV) ajaxWhiteList.push(/\\/livereload/)\n// 状态\nexport const EDITH_STATUS = {\n  INIT: 'INIT', // init阶段\n  WILL_MOUNT: 'WILL_MOUNT', // 即将mount阶段 （自检，安装插件）\n  DID_MOUNT: 'DID_MOUNT', // mounted阶段\n  CHECK_SELF: 'CHECK_SELF', // 自检\n  INSTALL_PLUGIN: 'INSTALL_PLUGIN', // 安装插件\n  LISTENING: 'LISTENING', // 错误监听中\n  COLLECTING: 'COLLECTING', // 错误收集中\n  SLEEP: 'SLEEP' // 不监听事件和上传\n}\n\n// 内置插件\nexport const innerPlugins = {\n  breadcrumbs: () => import('../plugins/BreadcrumbsPlugin'),\n  network: () => import('../plugins/NetworkCheckPlugin'),\n  redo: () => import('../plugins/RecordPlugin')\n}\nconst scriptPath = () => {\n  const url = document.currentScript.src\n  const link = document.createElement('a')\n  link.href = url\n  const path = (`${link.hostname}${link.port ?  ':' + link.port : ''}${link.pathname}`)\n  return path\n}\nexport const cdnUrl = `//${FORMAT === 'iife' && scriptPath() || 'webcdn.inke.cn/edith.cn'}`\nconst cdnPath = cdnUrl.replace(/\\/[^/]+$/, '')\n// 内置插件的cdn地址\nexport const innerPluginsCdn = {\n  breadcrumbs: {\n    link: `${cdnPath}/plugins/BreadcrumbsPlugin.js`,\n    name: 'BreadcrumbsPlugin'\n  },\n  network: {\n    link: `${cdnPath}/plugins/NetworkCheckPlugin.js`,\n    name: 'NetworkCheckPlugin'\n  } ,\n  redo: {\n    link: `${cdnPath}/plugins/RecordPlugin.js`,\n    name: 'RecordPlugin'\n  }\n}\nexport const remixProps = {\n  ajaxWhiteList, \n  resourceWhiteList: [\n    ...Object.keys(innerPluginsCdn).map(item => innerPluginsCdn[item].link),\n    '//webcdn.inke.cn/edith.cn/hm.gif']\n}\n","// /* eslint-disable no-undef */\n// import { compressToBase64 } from 'lz-string'\n// import { pack } from 'rrweb/lib/record/rrweb-record-pack'\nimport { pack } from './pack'\nimport { reportScriptError } from './api'\nimport { cdnUrl } from './config'\n// console.log(LZString.compress('object'))\nconst performance = window.performance\n/**\n * 参数格式化, 符合url方式\n * @params {Object} {a: '123', age: '18'}\n * @return {String} 'a=123&age=18'\n */\nexport const stringifyParams = (params, cb) => {\n  let name\n  let value\n  let str = ''\n\n  for (name in params) {\n    value = params[name]\n    str += name + '=' + (\n      typeof cb === 'function' ?\n        cb(value, name) :\n        value && typeof value === 'object' && !Object.getPrototypeOf(value).slice ? JSON.stringify(value) : value ) + '&'\n  }\n  return str.slice(0, -1)\n}\n\n// 获取ua环境信息\nexport const uaInfo = (() => {\n  const uaInfo = navigator.userAgent.match(/[^(\\s]+(\\s\\([^)]+\\))?/g)\n  return uaInfo\n})()\n\n\n/**\n * 把数据保存到本地\n */\nexport const saveLocalData = (key, item, isSession) => {\n  const storage = isSession ? sessionStorage : localStorage\n  try {\n    if (item === void 0) storage.removeItem(key)\n    else storage.setItem(key, JSON.stringify(item))\n  } catch (error) {\n    console.warn(error)\n  }\n}\n/**\n * 读取本地数据\n */\nexport const getLocalData = (key, isSession) => {\n  let res = null\n  try {\n    if (key === void 0) {\n      let allName = Object.keys(isSession ? sessionStorage : localStorage)\n      if (allName.length > 0) {\n        res = {}\n        allName.forEach((keyName) => {\n          res[keyName] = getLocalData(keyName)\n        })\n      }\n    } else\n      res = JSON.parse(\n        (isSession ? sessionStorage : localStorage).getItem(key)\n      )\n  } catch (error) {\n    console.warn(error)\n  }\n  return res\n}\n\n// 对方法进行封装，防止内部报错\nexport const tryCatchFn = (fn, edith) => function(...args) {\n    try {\n      typeof fn !== 'function' && (fn = () => {})\n      return fn.apply(this, args)\n    } catch (error) {\n      console.warn('edith 内部报错', error)\n      reportEdithError('EdithError', error, edith)\n    }\n  }\n\n// 通用事件监听方法\nexport const edithAddEventListener = (name, fn, useCapture) => {\n  \n  if (addEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早版本\n    addEventListener(name, tryCatchFn(fn), useCapture)\n  } else if (window.attachEvent) {\n    // IE 8 及更早版本\n    window.attachEvent(`on${name}`, tryCatchFn(fn))\n  }\n}\n\n\n// 执行环境监测以及性能\nexport const getPerform = () => {\n  // const getEntriesByType = 'getEntriesByType'\n  if (!performance) {\n    // console.warn('edith 内部报错: 当前环境不支持性能监控', )\n    return false\n  }\n  return {\n    timing: performance.timing,\n    // chromeLoadingTiming: chrome && chrome.loadTimes(),\n    // entriesTiming: {\n    //   navigation: per[getEntriesByType]('navigation'),\n    //   paint: per[getEntriesByType]('paint'),\n    //   resource: per[getEntriesByType]('resource').filter(item => !item.name.match(/hm\\.baidu\\.com\\/hm\\.gif/)),\n    // },\n  }\n}\n  \n\n// 异步加载scripts标签\nexport const loadScript = (url, cb, reject = () => {}) => {\n  const script = document.createElement('script')\n  script.setAttribute('cdn-rendered', '')\n  script.src = url\n  script.onload = cb\n  script.onerror = reject\n  document.getElementsByTagName('head')[0].appendChild(script)\n  // document.head.appendChild(script)\n}\n// 异步加载插件，封装成promise\nexport const loadCdnScript = (url, name) =>\n  new Promise((resolve, reject) => {\n    loadScript(url, () => resolve({ default: window.Edith[name] }), reject)\n  })\n\n// 避免map方法进入reject\nexport const getPromiseResult = (promises) => {\n  const handlePromise = Promise.all(\n    promises.map((fn) => (fn.catch ? fn.catch((err) => 0) : fn))\n  )\n  return handlePromise\n}\n\n\n\n// 得到Headers对象里的数据\nexport const getHeaders = h => {\n  const header = {}\n  if (h instanceof Headers) {\n    for (var p of h) {\n      header[p[0]] = p[1]\n    }\n    return header\n  }\n  return h\n}\nconst MORE_DATA_TIP = '[large size Edith Plugins Data]'\nconst MIN_SIZE = 6 * 1024 * 1024 // 4kb\nexport const minSize = tryCatchFn((params) => {\n  const res = {}\n  for (var name in params) {\n    var value = params[name]\n    res[name] = transToString(value) > MIN_SIZE\n          ? MORE_DATA_TIP\n          : value\n  }\n  return res\n})\n// 如果是Error，则取stack\nexport function transToString(p) {\n  return (p && typeof p === 'object' && p instanceof Error ? p.stack : p) || ''\n}\n// 压缩对象成加密压缩的字符串\nexport function compressData (p) {\n  p = pack(transToString(p))\n  return p\n}\nlet apiKey = ''\nexport function reportEdithError (name, err, edith) {\n  edith && edith.apiKey && (apiKey = edith.apiKey)\n  reportScriptError({\n    version: EDITH_VERSION,\n    format: FORMAT,\n    name,\n    message: compressData(err),\n    scriptUrl: cdnUrl,\n    userAgent: navigator.userAgent,\n    apiKey\n  })\n}\n\n// 将每个错误生成唯一key，用错判断是否为重复错误\nexport function getOnlyTag(err) {\n  \n}\n\n\n/*\n// 汉字转unicode\nexport const ch2Unicode = (data) => {\n  if (data === '') return ''\n  const res = data.replace(/([\\u4E00-\\u9FA5]|[\\uFE30-\\uFFA0])/g, function(\n    char\n  ) {\n    return '\\\\u' + char.charCodeAt(0).toString(16)\n  })\n  return res\n}\n// unicode转汉字\nexport const unicode2Ch = (asciicode) => {\n  asciicode = asciicode.split('\\\\u')\n  var nativeValue = asciicode[0]\n  for (var i = 1; i < asciicode.length; i++) {\n    var code = asciicode[i]\n    nativeValue += String.fromCharCode(parseInt('0x' + code.substring(0, 4)))\n    if (code.length > 4) {\n      nativeValue += code.substring(4, code.length)\n    }\n  }\n  return nativeValue.replace(/^[\\t\\r\\v\\n\\f\\0]+/, '')\n}\n*/\n","import { stringifyParams, tryCatchFn } from '../utils'\nlet xmlhttp = null\n\nconst getPromise = (xmlhttp, callback) => new Promise((resolve, reject) => {\n  xmlhttp.onreadystatechange = tryCatchFn(() => {\n    if(xmlhttp.readyState !== 4) return\n    var responseText = ['', 'text'].indexOf(xmlhttp.responseType) >= 0 ? xmlhttp.responseType : 'no responseText'\n    if (xmlhttp.status === 200) {\n      // console.log(xmlhttp.responseText)\n      let res = {}\n      try {\n        res = JSON.parse(responseText)\n      } catch(e){\n        res = responseText\n      }\n      resolve(res)\n    } else if(xmlhttp.status > 399) {\n      reject(responseText)\n    }\n  })\n  callback()\n})\n\nconst request = {\n  root: '/',\n  setRoot(host) {\n    this.root = host\n  },\n  getRootByUrl(url) {\n    url = url.replace(/^http(s?):\\/\\//, '//')\n    return url.match(/^\\/\\//) ? '' : this.root\n  },\n  get(url) {\n    return (parmas = {}) => {\n      xmlhttp = new XMLHttpRequest()\n      const root = this.getRootByUrl(url)\n      return getPromise(xmlhttp, () => {\n        xmlhttp.open('GET', `${root}${url}?${stringifyParams(parmas)}`, true)\n        // xmlhttp.withCredentials = true;\n        xmlhttp.send()\n      })\n    }\n  },\n  post(url) {\n    return (parmas = {}) => {\n      xmlhttp = new XMLHttpRequest()\n      const root = this.getRootByUrl(url)\n      const fn = () => {\n        xmlhttp.open('POST', `${root}${url}`, true)\n        xmlhttp.setRequestHeader('Content-type','application/json;charset=utf-8');\n        // xmlhttp.withCredentials = true;\n        xmlhttp.send(JSON.stringify(parmas));\n      }\n      if(IS_DEV){\n        return getPromise(xmlhttp, fn)\n      }else fn()\n    }\n  }\n}\n\nexport default request\n","// 接口文档： http://apidoc.csinke.cn/project/lmiSmNmmge.html\nimport reportRequest from './request'\nimport { serviceRoot } from '../config'\n\nreportRequest.setRoot(serviceRoot)\n\nexport const reportDebug = reportRequest.post('/v1/monitor/add'); //上报\n\nexport const measureBWSimple = reportRequest.get('/v1/upload/test-img'); //测试网速\n\nexport const reportScriptError = reportRequest.post('/v1/monitor/script-add') // 上报脚本自身错误\n\nif(IS_DEV) {\n  const postEnv = reportRequest.post('/v1/apikey-env/update'); //上报\n  window.postEnv = () => {\n    postEnv({apiKey: 'YXBpS2V5MTU5Mzc3Mzg1Ng', env: 'test', url: 'etdith', id: '19'}).then(res => {\n      // console.log(res)\n    }).catch(e => {})\n  }\n}\n","\nimport { isFunction } from '../common'\nimport { reportDebug, measureBWSimple } from '../api'\nimport { EDITH_STATUS, innerPluginsCdn, innerPlugins, remixProps } from '../config'\nimport { loadCdnScript, getPromiseResult, edithAddEventListener, minSize, compressData, reportEdithError, transToString } from '../utils'\n\nconst remix = ['resourceWhiteList', 'ajaxWhiteList']\n\nclass _Edith {\n  life = ''\n  plugins = []\n  state = {\n    plugins: {}\n  }\n\n  utils = {\n    compressData,\n    compressString: compressData,\n    measureBWSimple,\n    edithAddEventListener\n  }\n\n  $life (status) {\n    this.life = status\n  }\n\n  // change life\n  init = (nextState) => {\n    if (this.life) return console.warn('只需要初始化一次')\n    if(this._waitPromise(nextState)) return\n    const { apiKey, silentDev } = nextState || {}\n    if (!nextState || !apiKey) {\n      return console.warn('请传入项目的apiKey')\n    }\n    this.$life(EDITH_STATUS.INIT)\n    this.setState({ api_key: apiKey })\n    if (silentDev && location.host.match(/^localhost|[\\d.]+$/)) {\n      this.notListening = true // 不监听错误了\n    }\n    this._willMount(nextState);\n    this.initState = { ...this.state }\n    \n    // did\n    this._didMount(this.state);\n    // check\n    this._checkSelf().then(() => {\n      this.$life(EDITH_STATUS.INSTALL_PLUGIN)\n      // install plugns\n      this._installPlugins(this).then(() => {\n        // star\n        this._collecting(); // 加载插件立即初始化一次\n        this.initState = { ...this.state }\n      })\n      isFunction(this.pluginInstalled) && this.pluginInstalled()\n      this.$life(EDITH_STATUS.LISTENING)\n    }).catch(this._sleep.bind(this))\n  }\n  _waitPromise (nextState) {\n    if(window.Promise) return\n    edithAddEventListener('promisePolyfill', () => this.init(nextState))\n    return true\n  }\n\n  setState = (nextState, byPlugins) => {\n    if (this.life === EDITH_STATUS.COLLECTING && !byPlugins) return // 收集错误信息阶段，只允许收集插件的相关信息\n    const preState = this.state\n    this.state = { ...preState, ...nextState }\n  }\n\n  _willMount (nextState) {\n    const { plugins } = nextState\n    this.$life(EDITH_STATUS.WILL_MOUNT)\n    isFunction(this.willMount) && this.willMount(nextState)\n    this.plugins = plugins instanceof Array ? plugins : []\n    remix.forEach((key) => {\n      this[key] = [...remixProps[key], ...(nextState[key] || [])]\n    })\n  }\n\n  _didMount () {\n    this.$life(EDITH_STATUS.DID_MOUNT)\n    isFunction(this.didMount) && this.didMount()\n  }\n\n  _checkSelf () {\n    this.$life(EDITH_STATUS.CHECK_SELF)\n    return new Promise((resolve, reject) => {\n      if (isFunction(this.checkSelf)) {\n        try {\n          this.checkSelf()\n        } catch (e) {\n          console.log('edith自检发生错误', e)\n          reportEdithError('SelfCheckError', e)\n          reject(e)\n        }\n      }\n      resolve()\n    })\n  }\n\n  _installPlugins () { // 安装加载插件\n    return new Promise((resolve, reject) => {\n      // console.log(this.plugins)\n      const promiseList = []\n      this.plugins.forEach(plugin => {\n        if(!plugin) return\n        if (typeof plugin === 'string') {\n          if (FORMAT === 'iife') { // 如果打包成cdn链接\n            const inner = innerPluginsCdn[plugin]\n            inner && promiseList.push(loadCdnScript(inner.link, inner.name))\n          } else { // 如果打包成npm模块\n            const inner = innerPlugins[plugin]\n            inner && promiseList.push(inner())\n          }\n        } else promiseList.push(plugin)\n      })\n      getPromiseResult(promiseList).then((pluginList) => {\n        pluginList = pluginList.map(item => isFunction(item.default) ? new item.default() : item)\n        // 得到对应插件\n        pluginList.forEach((plugin) => {\n          plugin && remix.forEach((key) => { // 混入插件内部定义的链接白名单和http白名单\n            this[key] = [...this[key], ...(plugin[key] || [])]\n          })\n        })\n        this.plugins = pluginList\n        resolve()\n      })\n    })\n  }\n  // 非内置插件的字段数据都在plugins里，内置插件属性的值直接添加到state里\n  compilerCallback = (pluginName, subInfo) => {\n    const state = { [pluginName]: subInfo }\n    this.setState(innerPluginsCdn[pluginName] ? state : {\n      plugins: {\n        ...this.state.plugins,\n        ...state\n      }\n    }, true)\n  }\n\n  compiler = (pluginName, fn) => {\n    const compilerCallback = this.compilerCallback;\n    const that = this;\n    fn(this, function (subInfo) {\n      compilerCallback.call(that, pluginName, subInfo)\n    })\n  }\n\n  _collecting () { // 收集插件的数据,或用于插件数据初始化\n    this.plugins.forEach(plugin => {\n      const { name }= plugin.constructor\n      if (!plugin.apply) return innerPluginsCdn[plugin] || console.warn(`Edith插件[${plugin.constructor.name}]必须实现apply方法`)\n      try {\n        plugin.apply(this.compiler.bind(this))\n      } catch (e) {\n        reportEdithError('CollectError',{\n          error: transToString(e),\n          plugin: name,\n          life: this.life\n        })\n      }\n    })\n    isFunction(this.collecting) && this.collecting()\n  }\n\n  _sleep () {\n    this.$life(EDITH_STATUS.SLEEP); // 不上报，不检测\n    this.$life = () => { }\n    isFunction(this.sleep) && this.sleep()\n    this.$handleCollect = () => { } // 停止上传\n  }\n\n  reportDebug = reportDebug\n\n  // 上报\n  $handleCollect () {\n    if (this.life !== EDITH_STATUS.LISTENING) return // 收集错误信息过程中不上报\n    this.$life(EDITH_STATUS.COLLECTING)\n    var timer = setTimeout(() => { // 在所有队列后执行错误，避免点击立即出发的报错，没有记录点击事件\n      const parmas = { ...this.state }\n      const filtersParmas = {\n        name: parmas.name,\n        message: parmas.message,\n        url: parmas.url,\n        title: parmas.title,\n        ajax: parmas.extraInfo || {\n          url: ''\n        },\n        target: parmas.target || {},\n      }\n      // console.log(parmas)\n      if(!(this.filters(filtersParmas)) || parmas.type === 'customError'){\n        this._collecting() // 收集插件数据\n        this.reportDebug({\n          ...this.state,\n          plugins: compressData(minSize(this.state.plugins)) // 限制plugins数据大小\n        }) // filters方法返回真值，则代表拦截\n      } \n      this.state = this.initState //上报完成去掉\n      this.$life(EDITH_STATUS.LISTENING)\n      window.clearTimeout(timer)\n      timer = null\n    }, 16)\n  }\n}\n\nexport default _Edith\n"," // , getLocalData, saveLocalData\nimport { isFunction, isSuccess, eventTrigger, getCurrentTime, getRandomID } from './index'\n// import { getCLS, getFID, getLCP, getFCP } from 'web-vitals';\nimport { loadScript } from '../utils' // getPerform\n// import { reportDebug } from '../api'\n\n// CustomEvent的polyfill\nconst customEventPolyfill = function () {\n  if (isFunction(CustomEvent)) return false;\n  function CustomEvent (event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  CustomEvent.prototype = Event.prototype;\n  window.CustomEvent = CustomEvent;\n}\n\n// 封装XMLHttpRequest，为捕获ajax请求增加自定义事件, 以及内部方法封装，以拿到更多参数\n// xhr.getAllResponseHeaders()  响应头信息\n// xhr.requestHeader            请求头信息\n// xhr.responseText             响应内容\n// xhr.url                请求的地址\n// xhr.body                     post参数，（get参数在url上面）\nconst xhrProxy = function () {\n  const ajaxEvents = {\n    abort: 'ajaxAbort', // 请求中止\n    error: 'ajaxError', // 请求错误\n    // load: 'ajaxLoad', // 请求加载\n    // loadstart: 'ajaxLoadStart', // 请求加载开始\n    progress: 'ajaxProgress', // 请求中\n    timeout: 'ajaxTimeout', // 请求超时事件\n    loadend: 'ajaxLoadEnd', // 请求加载结束\n    // readystatechange: 'ajaxReadyStateChange', // 请求状态变化\n  }\n  // const uploadEvents = { // 上传事件\n  //   loadstart: 'uploadStart', // 请求加载开始\n  //   progress: 'uploadProgress', // 请求中\n  //   load: 'upload', // 请求加载\n  //   loadend: 'uploadEnd', // 请求加载结束\n  // }\n   \n  const XHR = window.XMLHttpRequest;\n  const spelEvents = ['error', 'timeout', 'abort']\n  function XMLHttpRequest() {\n    var realXHR = new XHR();\n    let isException = false\n    Object.keys(ajaxEvents).forEach(eventName => {\n      realXHR.addEventListener(eventName,\n        function (e) {\n          eventTrigger.call(this, ajaxEvents[eventName]);\n          isException || (isException = spelEvents.indexOf(eventName) >= 0)\n          if (eventName === 'loadend') {\n            if (!isSuccess(this.status) && !isException) { // 判断状态码,是否是成功的请求,而且不是已经报错了的请求\n              eventTrigger.call(this, ajaxEvents['error'])\n            }\n          }\n        }, false);\n    })\n    // Object.keys(uploadEvents).forEach(eventName => {\n    //   realXHR.upload.addEventListener(eventName,\n    //     function () {\n    //       eventTrigger.call(this, uploadEvents[eventName]);\n    //     }, false);\n    // })\n\n    // 封装send方法\n    const send = realXHR.send;\n    realXHR.send = function (...arg) {\n      send.apply(realXHR, arg);\n      realXHR.body = arg[0];\n    }\n    // 封装open方法\n    const open = realXHR.open;\n    realXHR.open = function (...arg) {\n      realXHR.method = arg[0]\n      realXHR.url = arg[1]\n      realXHR.async = arg[2]\n      realXHR.startTime = getCurrentTime() // startTime必须以绝对时间来计算\n      eventTrigger.call(realXHR, 'ajaxOpen')\n      open.apply(realXHR, arg)\n    }\n    // 封装setRequestHeader方法\n    // const fn = 'setRequestHeader'\n    // const setRequestHeader = realXHR[fn]\n    // realXHR.requestHeader = {};\n    // realXHR[fn] = function (name, value) {\n    //   realXHR.requestHeader[name] = value;\n    //   setRequestHeader.call(realXHR, name, value)\n    // }\n\n    return realXHR;\n  }\n  window.XMLHttpRequest = XMLHttpRequest;\n}\n// 封装fetch\nconst fetchProxy = function () {\n  //拦截原始的fetch方法\n  const oldFetchfn = window.fetch;\n  if (!oldFetchfn) return\n  window.fetch = function (arg, opt) {\n    const now = getCurrentTime()\n    let options = {\n      startTime: now,\n      status: 0,\n      body: null,\n      statusText: '',\n      // getAllResponseHeaders: () => ({}),\n      _eid: getRandomID(),\n    }\n    if(window.Request && arg instanceof window.Request) {\n      const { url, method, body } = arg // , headers: getHeaders(headers)\n      options = { ...options, url, method, body,  }\n    } else options = {\n      url: arg,\n      method: 'GET',\n      ...options,\n      ...opt,\n      // headers: getHeaders(opt.headers),\n    }\n    \n    eventTrigger.call({ options }, 'fetchStart')\n    return oldFetchfn.apply(this, [arg, opt]).then(res => {\n      res.options = options\n      if (!isSuccess(res.status)) { // 判断状态码。是否是成功的请求\n        eventTrigger.call({ options }, 'fetchError')\n      }\n      eventTrigger.call({ options }, 'fetchEnd')\n      return res\n    }, err => {\n      err.options = options\n      eventTrigger.call({ options }, 'fetchError')\n    })\n  }\n}\n/*\n// 性能监控以及埋点\nfunction performanceRecode () {\n  const page = location.pathname\n  let performanceData = JSON.parse(JSON.stringify(getPerform()))\n  if (!performanceData) return;\n  const oldPerformanceData = getLocalData('performance') || {}\n  let havePage = false;\n  let currentDate = new Date().toLocaleDateString();\n  Object.keys(oldPerformanceData).forEach(item => {\n    if (item !== page) return\n    let oldData = oldPerformanceData[item]\n    // 如果时间相同就不上报改为求平均值\n    if (currentDate === oldData.currentDate) {\n      // 计算当日打开次数\n      performanceData.count = oldData.count + 1\n      for (var key in performanceData.timing) {\n        performanceData.timing[key] = (oldData.timing[key] * oldData.count + performanceData.timing[key]) / performanceData.count\n      }\n      performanceData.currentDate = currentDate\n      oldPerformanceData[item] = {\n        ...oldPerformanceData[item],\n        ...performanceData\n      }\n    } else {\n      reportDebug(oldData)\n      oldPerformanceData[item] = {\n        ...oldPerformanceData[item],\n        ...performanceData,\n        count: 1,\n        currentDate,\n      }\n    }\n    havePage = true\n  })\n  if (!havePage) {\n    oldPerformanceData[page] = {\n      ...performanceData,\n      count: 1,\n      currentDate,\n    }\n  }\n  saveLocalData('performance', oldPerformanceData)\n  // 累计位移偏移，CLS（Cumulative Layout Shift），记录了页面上非预期的位移波动。\n  // getCLS(setToPageStorage('CLS', page));\n  // 首次输入延迟，FID（First Input Delay），记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。\n  // getFID(setToPageStorage('FID', page));\n  // 最大内容绘制，LCP（Largest Contentful Paint），\n  // getLCP(setToPageStorage('LCP', page));\n  // 首次内容绘制，FCP（First Contentful Paint），这个指标用于记录页面首次绘制文本、图片、非空白 Canvas 或 SVG 的时间。\n  // getFCP(setToPageStorage('FCP', page))\n}\n\nfunction setToPageStorage (type, page) {\n  return function (message) {\n    const performanceData = getLocalData('performance')\n    Object.keys(performanceData).forEach(item => {\n      if (item === page) {\n        performanceData[item][type] = (message.value + performanceData[item][type] * (performanceData[item].count - 1)) / performanceData[item].count\n      }\n    })\n    saveLocalData('performance', performanceData)\n  }\n}\n*/\n\nfunction promisePolyfill () {\n  if(window.Promise) return\n  loadScript('//webcdn.inke.cn/tpc/common/es6-promise/3.2.2/es6-promise.min.js', () => {\n    eventTrigger.call(this, 'promisePolyfill')\n  })\n}\n\npromisePolyfill()\nexport default function () {\n  customEventPolyfill()\n  // xhrProxy() // 给XHR注册事件\n  // fetchProxy() // 给fetch注册事件\n  // performanceRecode()\n}\n\n//封装WebSocket\n(function() {\n  const oldWs = WebSocket; \n  if(!oldWs) return\n  const wsEvents = {\n    open: 'webSocketOpen',\n    error: 'webSocketError',\n    close: 'webSocketClose',\n  }\n  WebSocket = function (url, protocol) {\n    const ws = new oldWs(url, protocol);\n    ws.startTime = getCurrentTime()\n    eventTrigger.call(ws, 'webSocketStart')\n    \n    Object.keys(wsEvents).forEach(eventName => {\n      ws.addEventListener(eventName,\n        function (e) {\n          eventTrigger.call(this, wsEvents[eventName]);\n        }, false);\n    })\n    return ws\n  }\n})()\n\n\n","import _Edith from './prototype'\nimport reportRequest from './api/request'\nimport registBaseEvent from './common/registBaseEvent'\nimport { getErrorInfo, getCurrentTime, getTimeStamp, getTagName, getSimpleString,\n  getXPath, isFunction, setScriptCross, isWhite } from  './common'\nimport { PROMISE_TIMEOUT, EDITH_STATUS } from './config'\nimport { tryCatchFn, edithAddEventListener, transToString} from './utils'\n\nclass EdithClass extends _Edith {\n\n  silentDev = false // 是否开发环境不上报\n  silentPromise = false // 是否需要不监控Promise\n  silentWebsocket = false // 是否需要不监控 WebSocket\n  silentResource = false // 是否需要不监控资源加载异常\n  silentHttp = false // 是否需要不监控网络请求异常\n  setHttpBody = false // 是否需要上报post的body\n  version = EDITH_VERSION // 版本号\n\n  willMount(options) {\n    for(var prop in options){\n      if(options[prop] !== void 0 && !isFunction(this[prop]) && prop !== 'version')\n        this[prop] = options[prop]\n    }\n    const tryCatchFunc = fn => tryCatchFn(fn, this)\n    this.utils = {\n      ...this.utils,\n      getCurrentTime,\n      getSimpleString,\n      tryCatchFunc\n    }\n    this.filters = options.filters && tryCatchFunc(options.filters)\n  }\n  didMount() {\n    registBaseEvent() // 注册基础事件\n  }\n\n  // sleep() {\n  //   console.log('sleep')\n  // }\n\n  checkSelf() { // 自定义自检方法\n    this.handleError({ type: 'error', target: window })\n    this.silentResource || this.handleError({ type: 'error', target: {src: '', tagName: 'a', outerHTML: '', parentNode: document} })\n    this.silentHttp || this.handleError({ type: 'ajaxError', detail: { target: { url: ''} } })\n    this.silentHttp || this.handleError({ type: 'fetchError', detail: { target: {options: {url: ''}} } })\n  }\n\n  pluginInstalled() {\n    if(this.notListening) return\n    setScriptCross()\n    // 全局error监听，js报错，包括资源加载报错\n    edithAddEventListener('error', this.handleError, true)\n    // 全局promise no catch error监听，捕获未处理的promise异常\n    // 支持性不太好,IE不支持,低版本浏览器也不支持\n    this.silentPromise || edithAddEventListener('unhandledrejection', this.handlePromise)\n    // 网络请求的err\n    this.silentHttp || edithAddEventListener('ajaxError', this.handleError)\n    this.silentHttp || edithAddEventListener('ajaxTimeout', this.handleError)\n    this.silentHttp || edithAddEventListener('fetchError', this.handleError)\n    this.silentWebsocket || edithAddEventListener('webSocketError', this.handleError)\n  }\n  \n  //  捕获到错误时的回调函数\n  handleError = errorEvent => {\n    errorEvent = this.errorHandleFunc[errorEvent.type](errorEvent)\n    if(!errorEvent) return\n    const event = getErrorInfo(errorEvent)\n    if(this.life !== EDITH_STATUS.LISTENING) return\n    this.setState({\n      ...this.state,\n      ...event\n    }) \n    this.$handleCollect()\n  }\n\n  // 处理primise报错，设置了一个修复机制\n  handlePromise = (e, pro) => {\n    const { tryCatchFunc } = this.utils\n    let promiseTimer = setTimeout(tryCatchFunc(() => {\n      const { reason } = e\n      e.message = Object.prototype.toString.call(reason) === '[object Error]'? reason.toString() : transToString(reason)\n      e.name = 'unhandledrejection'\n      e._type = 'error'\n      const event = getErrorInfo(e)\n      this.setState({\n        ...this.state,\n        ...event\n      })\n      clearTimeout(promiseTimer)\n      this.$handleCollect()\n    }), PROMISE_TIMEOUT)\n    window.onrejectionhandled = tryCatchFunc((event, promise)=> {\n      if(pro !== promise) return\n      if(promiseTimer) clearTimeout(promiseTimer)\n    })\n  }\n  debug(name, message) {\n    this.setState({\n      ...this.state,\n      ...getErrorInfo({\n        name: transToString(name),\n        message: transToString(message),\n        timeStamp: getTimeStamp(),\n        type: 'customError'\n      })\n    })\n    this.$handleCollect()\n  }\n  errorHandleFunc = {\n    webSocketError : errorEvent => {\n      errorEvent.name = 'webSocketError';\n      errorEvent._type = 'webSocketError'\n      const errorTarget = errorEvent.detail.target || errorEvent.detail.currentTarget;\n      const { url, startTime , openTime} = errorTarget\n      if(isWhite(this.ajaxWhiteList, url)) return // 白名单不做上报\n      errorEvent.extraInfo = {\n        url,\n        elapsedTime : getCurrentTime() - (openTime || startTime)\n      }\n      return errorEvent\n    },\n    resourceError: errorEvent => {\n      if(this.silentResource) return\n      const errorTarget = errorEvent.target\n      // 元素错误，比如引用资源报错，只是普通事件，不是ErrorEvent；html标签的资源报错，暂时不知道发生在哪一行。\n      const tagName = getTagName(errorTarget).toLowerCase()\n      let sourceUrl = ''\n      if(tagName === 'link') {\n        sourceUrl = errorTarget.href\n      } else sourceUrl = errorTarget.src\n      if(isWhite(this.resourceWhiteList, sourceUrl)) return // 白名单不做上报\n      sourceUrl.split('?')[0] === location.href.split('?')[0] && (sourceUrl = '')\n      errorEvent.message = sourceUrl\n      errorEvent.name = errorEvent._type = 'resourceError'\n      errorEvent._target = {\n        tagName,\n        className: errorTarget.className,\n        id: errorTarget.id,\n        outerHTML: this.utils.getSimpleString(errorTarget.outerHTML),\n        xPath: getXPath(errorTarget)\n      }\n      return errorEvent\n    },\n    ajaxError: errorEvent => {\n      errorEvent._type = 'httpError'\n      errorEvent.name = 'ajaxError'\n      const { target: xhr, time } = errorEvent.detail\n      const { method, url, startTime, responseText, statusText, status } = xhr\n      if(isWhite(this.ajaxWhiteList, url)) return //白名单接口不记录\n      errorEvent.extraInfo = {\n        elapsedTime: time - startTime,\n        responseText,\n        status,\n        statusText,\n        method,\n        url\n      }\n      this.setHttpBody && (errorEvent.extraInfo.body = xhr.body)\n      // if(this.httpHeader) {\n      //   errorEvent.extraInfo.responseHeader = xhr.getAllResponseHeaders() || {}\n      //   errorEvent.extraInfo.requestHeader = requestHeader\n      // }\n      return errorEvent\n    },\n    fetchError: errorEvent => {\n      const { target: { options }, time } = errorEvent.detail\n      // console.log(options)\n      if(isWhite(this.ajaxWhiteList, options.url)) return //白名单接口不记录\n      errorEvent._type = 'httpError'\n      errorEvent.name = errorEvent.message = 'fetchError'\n      errorEvent.error = errorEvent.detail\n      errorEvent.extraInfo = {\n        elapsedTime: time - options.startTime,\n        ...options\n      }\n      if(!this.setHttpBody) delete errorEvent.extraInfo.body\n      \n      return errorEvent\n    },\n    error: errorEvent => {\n      const errorTarget = errorEvent.target\n      if (errorTarget !== window) { // 资源加载错误\n        return this.errorHandleFunc['resourceError'](errorEvent)\n      }\n      return errorEvent\n    }\n  }\n\n  _changeReportUrl(url) {\n    if(!url) return\n    this.ajaxWhiteList.push(url)\n    this.reportDebug = reportRequest.post(url + '')\n  }\n}\n\nconst Edith = new EdithClass()\nexport default Edith\n"],"names":["ua","navigator","userAgent","referrer","document","getCurrentTime","Date","getTime","getRandomID","Math","random","slice","getTimeStamp","performance","now","eventTrigger","event","window","dispatchEvent","CustomEvent","detail","target","this","time","isFunction","fn","getXPath","element","id","body","tagName","toLowerCase","ix","siblings","parentNode","childNodes","i","l","length","sibling","nodeType","getSimpleString","str","JSON","stringify","len","max","substr","removeHttpAndQuery","url","replace","split","isWhite","list","some","RegExp","test","isIE8","indexOf","match","getTagName","el","outerHTML","getErrorInfo","err","error","type","_type","name","message","_ref","description","extraInfo","stacktrace","stack","_target","timeStamp","title","location","href","columnNumber","colno","lineNumber","lineno","cookie","version","u8","Uint8Array","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","r","j","_a","fl","revfl","revfd","rev","x","hMap","cd","mb","s","co","le","rvb","sv","r_1","v","m","flt","fdt","flm","fdm","shft","p","slc","e","n","set","subarray","wbits","d","o","wbits16","hTree","t","push","f","t2","sort","a","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","i2_1","i2_2","i2_3","lc","c","cl","cli","cln","cls","w","clen","cf","wfblk","out","pos","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","_b","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","dst","deo","et","dopt","opt","pre","post","st","lvl","plvl","lst","floor","msk_1","prev","head","bs1_1","ceil","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","min","maxd","ml","nl","mmd","md","ti","lin","din","dflt","level","mem","log","zlibSync","data","opts","adler","lv","zlh","wbytes","pack","latin1","TextDecoder","decode","String","fromCharCode","strFromU8","TextEncoder","encode","ar","ai","charCodeAt","strToU8","EDITH_STATUS","innerPlugins","breadcrumbs","import","network","redo","cdnUrl","cdnPath","innerPluginsCdn","link","remixProps","ajaxWhiteList","resourceWhiteList","Object","keys","map","item","tryCatchFn","edith","args","apply","console","warn","reportEdithError","edithAddEventListener","useCapture","addEventListener","attachEvent","minSize","params","res","value","transToString","Error","compressData","apiKey","reportScriptError","format","scriptUrl","xmlhttp","request","root","setRoot","host","getRootByUrl","get","parmas","XMLHttpRequest","_this","callback","Promise","resolve","reject","onreadystatechange","readyState","responseText","responseType","status","parse","getPromise","open","cb","getPrototypeOf","stringifyParams","send","_this2","setRequestHeader","reportRequest","reportDebug","measureBWSimple","remix","_Edith","life","plugins","state","utils","compressString","init","nextState","_waitPromise","silentDev","$life","setState","api_key","notListening","_willMount","initState","_didMount","_checkSelf","then","_installPlugins","_collecting","pluginInstalled","catch","_sleep","bind","byPlugins","preState","compilerCallback","pluginName","subInfo","compiler","that","call","willMount","Array","forEach","key","_this3","didMount","_this4","checkSelf","promises","promiseList","_this5","plugin","inner","all","pluginList","default","constructor","_this6","collecting","sleep","$handleCollect","timer","setTimeout","_this7","filtersParmas","ajax","filters","clearTimeout","bubbles","cancelable","undefined","evt","createEvent","initCustomEvent","prototype","Event","customEventPolyfill","script","createElement","setAttribute","src","onload","onerror","getElementsByTagName","appendChild","loadScript","promisePolyfill","oldWs","WebSocket","wsEvents","close","protocol","ws","startTime","eventName","Edith","silentPromise","silentWebsocket","silentResource","silentHttp","setHttpBody","handleError","errorEvent","errorHandleFunc","handlePromise","pro","tryCatchFunc","promiseTimer","reason","toString","onrejectionhandled","promise","webSocketError","errorTarget","currentTarget","openTime","elapsedTime","resourceError","sourceUrl","className","xPath","ajaxError","xhr","method","statusText","fetchError","options","prop","registBaseEvent","setScriptCross","debug","_changeReportUrl"],"mappings":"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"}